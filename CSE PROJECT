#!/usr/bin/env python3
"""
Notes Manager / To-Do List App
File: notes_app.py
Python 3.8+
Simple console-based notes manager with JSON persistence.
"""

import json
import csv
import uuid
from datetime import datetime
from typing import List, Dict, Optional
import os
import tempfile
import shutil

DATA_FILE = "notes.json"
EXPORT_DIR = "exports"

# ---------- Models ----------
class Note:
    def __init__(self,
                 id: Optional[str],
                 title: str,
                 content: str,
                 category: str = "General",
                 priority: str = "Normal",
                 created_at: Optional[str] = None,
                 updated_at: Optional[str] = None):
        self.id = id or str(uuid.uuid4())
        self.title = title
        self.content = content
        self.category = category
        self.priority = priority
        now = datetime.utcnow().isoformat()
        self.created_at = created_at or now
        self.updated_at = updated_at or now

    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "title": self.title,
            "content": self.content,
            "category": self.category,
            "priority": self.priority,
            "created_at": self.created_at,
            "updated_at": self.updated_at,
        }

    @staticmethod
    def from_dict(d: Dict):
        return Note(
            id=d.get("id"),
            title=d.get("title", ""),
            content=d.get("content", ""),
            category=d.get("category", "General"),
            priority=d.get("priority", "Normal"),
            created_at=d.get("created_at"),
            updated_at=d.get("updated_at"),
        )

# ---------- Storage ----------
class Storage:
    def __init__(self, filepath: str = DATA_FILE):
        self.filepath = filepath

    def read(self) -> List[Dict]:
        if not os.path.exists(self.filepath):
            return []
        with open(self.filepath, "r", encoding="utf-8") as f:
            try:
                return json.load(f)
            except json.JSONDecodeError:
                print("Warning: Data file corrupted; starting with empty list.")
                return []

    def write(self, data: List[Dict]) -> None:
        # Atomic write: write to temp then replace
        dirpath = os.path.dirname(os.path.abspath(self.filepath)) or "."
        fd, tmp = tempfile.mkstemp(dir=dirpath)
        try:
            with os.fdopen(fd, "w", encoding="utf-8") as tmpf:
                json.dump(data, tmpf, indent=2, ensure_ascii=False)
            shutil.move(tmp, self.filepath)
        except Exception as e:
            print("Error writing data file:", e)
            if os.path.exists(tmp):
                os.remove(tmp)

# ---------- Note Manager ----------
class NoteManager:
    def __init__(self, storage: Storage):
        self.storage = storage
        self.notes: List[Note] = []
        self.load()

    def load(self):
        raw = self.storage.read()
        self.notes = [Note.from_dict(d) for d in raw]

    def save(self):
        data = [n.to_dict() for n in self.notes]
        self.storage.write(data)

    def create_note(self, title: str, content: str, category: str = "General", priority: str = "Normal") -> Note:
        note = Note(id=None, title=title.strip(), content=content.strip(), category=category.strip(), priority=priority.strip())
        self.notes.append(note)
        self.save()
        return note

    def list_notes(self, sort_by: str = "created_at") -> List[Note]:
        return sorted(self.notes, key=lambda n: getattr(n, sort_by), reverse=True)

    def get_note_by_id(self, note_id: str) -> Optional[Note]:
        for n in self.notes:
            if n.id == note_id:
                return n
        return None

    def update_note(self, note_id: str, title: Optional[str], content: Optional[str], category: Optional[str], priority: Optional[str]) -> bool:
        n = self.get_note_by_id(note_id)
        if not n:
            return False
        if title:
            n.title = title.strip()
        if content:
            n.content = content.strip()
        if category:
            n.category = category.strip()
        if priority:
            n.priority = priority.strip()
        n.updated_at = datetime.utcnow().isoformat()
        self.save()
        return True

    def delete_note(self, note_id: str) -> bool:
        n = self.get_note_by_id(note_id)
        if not n:
            return False
        self.notes.remove(n)
        self.save()
        return True

    def search_notes(self, keyword: str = "", category: str = "", priority: str = "") -> List[Note]:
        kw = keyword.lower().strip()
        res = []
        for n in self.notes:
            if kw and not (kw in n.title.lower() or kw in n.content.lower()):
                continue
            if category and category.lower() != n.category.lower():
                continue
            if priority and priority.lower() != n.priority.lower():
                continue
            res.append(n)
        return res

    def export_csv(self, filename: Optional[str] = None) -> str:
        if not os.path.exists(EXPORT_DIR):
            os.makedirs(EXPORT_DIR)
        filename = filename or f"notes_export_{datetime.utcnow().strftime('%Y%m%d%H%M%S')}.csv"
        path = os.path.join(EXPORT_DIR, filename)
        with open(path, "w", newline="", encoding="utf-8") as csvfile:
            writer = csv.writer(csvfile)
            writer.writerow(["id", "title", "content", "category", "priority", "created_at", "updated_at"])
            for n in self.notes:
                writer.writerow([n.id, n.title, n.content, n.category, n.priority, n.created_at, n.updated_at])
        return path

    def import_json(self, path: str) -> int:
        if not os.path.exists(path):
            raise FileNotFoundError(path)
        with open(path, "r", encoding="utf-8") as f:
            raw = json.load(f)
        count = 0
        for d in raw:
            note = Note.from_dict(d)
            # if note id exists, skip
            if self.get_note_by_id(note.id):
                continue
            self.notes.append(note)
            count += 1
        self.save()
        return count

    def stats(self) -> Dict:
        total = len(self.notes)
        by_cat = {}
        for n in self.notes:
            by_cat[n.category] = by_cat.get(n.category, 0) + 1
        return {"total": total, "by_category": by_cat}

# ---------- Console UI ----------
def prompt(prompt_text: str, default: Optional[str] = None) -> str:
    if default:
        return input(f"{prompt_text} [{default}]: ") or default
    return input(f"{prompt_text}: ")

def print_note_brief(n: Note):
    print(f"ID: {n.id}\nTitle: {n.title}\nCategory: {n.category}\nPriority: {n.priority}\nCreated: {n.created_at}\nUpdated: {n.updated_at}\n---")

def print_note_full(n: Note):
    print_note_brief(n)
    print(n.content)
    print("-" * 40)

def main_menu():
    storage = Storage()
    nm = NoteManager(storage)

    while True:
        print("\n=== Notes Manager ===")
        print("1) Create Note")
        print("2) List Notes")
        print("3) View Note (by ID)")
        print("4) Edit Note")
        print("5) Delete Note")
        print("6) Search / Filter")
        print("7) Export to CSV")
        print("8) Import from JSON")
        print("9) Stats")
        print("0) Exit")
        choice = input("Choose (0-9): ").strip()
        if choice == "1":
            title = prompt("Title")
            content = prompt("Content")
            category = prompt("Category", "General")
            priority = prompt("Priority (Low/Normal/High)", "Normal")
            note = nm.create_note(title, content, category, priority)
            print("Created note with ID:", note.id)
        elif choice == "2":
            notes = nm.list_notes()
            if not notes:
                print("No notes yet.")
            for n in notes:
                print_note_brief(n)
        elif choice == "3":
            nid = prompt("Note ID")
            n = nm.get_note_by_id(nid)
            if not n:
                print("Note not found.")
            else:
                print_note_full(n)
        elif choice == "4":
            nid = prompt("Note ID to edit")
            n = nm.get_note_by_id(nid)
            if not n:
                print("Note not found.")
                continue
            print("Leave blank to keep existing.")
            title = prompt("New Title", n.title)
            content = prompt("New Content", n.content)
            category = prompt("New Category", n.category)
            priority = prompt("New Priority", n.priority)
            ok = nm.update_note(nid, title, content, category, priority)
            print("Updated." if ok else "Failed to update.")
        elif choice == "5":
            nid = prompt("Note ID to delete")
            n = nm.get_note_by_id(nid)
            if not n:
                print("Note not found.")
                continue
            confirm = input(f"Delete '{n.title}'? (y/N): ").strip().lower()
            if confirm == "y":
                nm.delete_note(nid)
                print("Deleted.")
            else:
                print("Cancelled.")
        elif choice == "6":
            kw = prompt("Keyword (in title/content)", "")
            cat = prompt("Category (blank for any)", "")
            pr = prompt("Priority (Low/Normal/High) (blank for any)", "")
            results = nm.search_notes(kw, cat, pr)
            if not results:
                print("No matches.")
            for n in results:
                print_note_brief(n)
        elif choice == "7":
            path = nm.export_csv()
            print("Exported to:", path)
        elif choice == "8":
            path = prompt("JSON file path to import (relative or absolute)")
            try:
                count = nm.import_json(path)
                print(f"Imported {count} new notes.")
            except Exception as e:
                print("Import failed:", e)
        elif choice == "9":
            s = nm.stats()
            print("Total notes:", s["total"])
            print("By category:")
            for c, ct in s["by_category"].items():
                print(f"  {c}: {ct}")
        elif choice == "0":
            print("Goodbye!")
            break
        else:
            print("Invalid choice. Try again.")

if __name__ == "__main__":
    main_menu()
